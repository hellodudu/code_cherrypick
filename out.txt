func (m *MsgParser) decodeToProto(data []byte) (proto.Message, error) {

	// discard top 8 bytes of message size and message crc id
	byProto := data[8:]

	// get next 2 bytes of message name length
	protoNameLen := binary.LittleEndian.Uint16(byProto[:2])

	if uint16(len(byProto)) < 2+protoNameLen {
		return nil, fmt.Errorf("recv proto msg length < 2+protoNameLen:" + string(byProto))
	}

	// get proto name
	protoTypeName := string(byProto[2 : 2+protoNameLen])
	pType := proto.MessageType(protoTypeName)
	if pType == nil {
		return nil, fmt.Errorf("invalid message<%s>, won't deal with it", protoTypeName)
	}

	// get proto data
	protoData := byProto[2+protoNameLen:]

	// prepare proto struct to be unmarshaled in
	newProto, ok := reflect.New(pType.Elem()).Interface().(proto.Message)
	if !ok {
		return nil, fmt.Errorf("invalid message<%s>, won't deal with it", protoTypeName)
	}

	// unmarshal
	if err := proto.Unmarshal(protoData, newProto); err != nil {
		logger.Warning("Failed to parse proto msg:", newProto, err)
		return nil, fmt.Errorf("invalid message<%s>, won't deal with it", protoTypeName)
	}

	return newProto, nil
}

// top 8 bytes are baseNetMsg
// if it is protobuf msg, then next 2 bytes are proto name length, the next is proto name, final is proto data.
// if it is transfer msg(transfer binarys to other world), then next are binarys to be transferd
func (m *MsgParser) ParserMessage(con iface.ITCPConn, data []byte) {
	if len(data) <= 8 {
		logger.Warning("tcp recv data length <= 8:", string(data))
		return
	}

	baseMsg := &global.BaseNetMsg{}
	byBaseMsg := make([]byte, binary.Size(baseMsg))

	copy(byBaseMsg, data[:binary.Size(baseMsg)])
type arenaData struct {
	Playerid   int64  `gorm:"type:bigint(20);primary_key;column:player_id;default:-1;not null"`
	Score      int32  `gorm:"type:int(10);column:score;default:0;not null"`
	ReachTime  uint32 `gorm:"type:int(10);column:reach_time;default:0;not null"`
	LastTarget int64  `gorm:"type:bigint(20);column:last_target;default:-1;not null"` // target cannot be last one
}

func (arenaData) TableName() string {
	return "arena_player"
}

// champion data
type championData struct {
	Rank       int    `gorm:"type:smallint(5);primary_key;column:champion_rank;default:0;not null"`
	PlayerID   int64  `gorm:"type:bigint(20);column:player_id;default:-1;not null"`
	Score      int    `gorm:"type:int(10);column:score;default:0;not null"`
	Season     int    `gorm:"type:int(10);column:arena_season;default:0;not null"`
	PlayerName string `gorm:"type:varchar(32);column:player_name;default:'';not null"`
	ServerName string `gorm:"type:varchar(32);column:server_name;default:'';not null"`
	MasterID   int    `gorm:"type:int(10);column:master_id;default:1;not null"`
	FashionID  int    `gorm:"type:int(10);column:fashion_id;default:-1;not null"`
}

func (championData) TableName() string {
	return "arena_champion"
}

func getSectionIndexByScore(score int32) int32 {
	if score < 1200 {
		return 0
	} else if score < 1500 {
		return 1
	} else if score < 1800 {
		return 2
	} else if score < 2100 {
		return 3
	} else if score < 2500 {
		return 4
	} else if score < 3000 {
		return 5
	} else if score < 3600 {
		return 6
	} else {
		return 7
	}
}

func getDefaultScoreBySection(secIdx int32) int32 {
	var def int32 = 1000
	switch secIdx {
// 	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
// 	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
// 	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
// 	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
// 	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
// 	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
// 	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
// 	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
// 	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
// 	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
// 	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
// 	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
// 	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
// 	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
// 	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
// 	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
// 	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
// 	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
// }

// func Crc32(str string) uint32 {
// 	var crc uint32
// 	crc = 0 ^ 0xffffffff
// 	for _, v := range str {
// 		crc = (crc >> 8) ^ CrcTable[(crc&0xff)^uint32(v)]
// 	}
// 	return crc ^ 0xffffffff
// }

func Crc32(str string) uint32 {
	return crc32.ChecksumIEEE([]byte(str))
}
func (umt *ultimate) InitDatastore() {
	var err error
	if umt.ds, err = datastore.NewDatastore(); err != nil {
		logger.Fatal(err)
		return
	}
	logger.Print("datastore init ok!")
}

func (umt *ultimate) InitRedis() {
	umt.rds = redis.NewClient(&redis.Options{
		Addr:     global.RedisAddr,
		Password: global.RedisPwd,
		DB:       global.RedisDB,
	})

	if _, err := umt.rds.Ping().Result(); err != nil {
		logger.Fatal(err)
		return
	}

	logger.Print("redis init ok")
}

func (umt *ultimate) InitMsgParser() {
	if umt.mp = NewMsgParser(umt.gm, umt.wm); umt.mp == nil {
		logger.Fatal("cannot new msg_parser")
	}

	logger.Print("msg parser init ok!")
}

// InitTCPServer init
func (umt *ultimate) InitTCPServer() {
	var err error
	if umt.tcpServ, err = NewTcpServer(umt.mp, umt.td); err != nil {
		logger.Fatal(err)
	}

	logger.Print("tcp_server init ok!")
}

// InitRPCServer init
func (umt *ultimate) InitRPCServer() {
	var err error
	if umt.rpcServ, err = NewRpcServer(umt.gm); err != nil {
		logger.Fatal(err)
	}

	logger.Print("rpc_server init ok!")
type HeroRecord struct {
	EntityId             uint32   `protobuf:"varint,1,opt,name=entity_id,json=entityId,proto3" json:"entity_id,omitempty"`
	StateFlag            int32    `protobuf:"varint,2,opt,name=state_flag,json=stateFlag,proto3" json:"state_flag,omitempty"`
	FashionId            int32    `protobuf:"varint,3,opt,name=fashion_id,json=fashionId,proto3" json:"fashion_id,omitempty"`
	MountTypeId          uint32   `protobuf:"varint,4,opt,name=mount_type_id,json=mountTypeId,proto3" json:"mount_type_id,omitempty"`
	RageLevel            int32    `protobuf:"varint,5,opt,name=rage_level,json=rageLevel,proto3" json:"rage_level,omitempty"`
	Level                int32    `protobuf:"varint,6,opt,name=level,proto3" json:"level,omitempty"`
	Att                  []int32  `protobuf:"varint,7,rep,packed,name=att,proto3" json:"att,omitempty"`
	BaseAtt              []int32  `protobuf:"varint,8,rep,packed,name=base_att,json=baseAtt,proto3" json:"base_att,omitempty"`
	BaseAttModPct        []int32  `protobuf:"varint,9,rep,packed,name=base_att_mod_pct,json=baseAttModPct,proto3" json:"base_att_mod_pct,omitempty"`
	AttMod               []int32  `protobuf:"varint,10,rep,packed,name=att_mod,json=attMod,proto3" json:"att_mod,omitempty"`
	AttModPct            []int32  `protobuf:"varint,11,rep,packed,name=att_mod_pct,json=attModPct,proto3" json:"att_mod_pct,omitempty"`
	PassiveSpell         []uint32 `protobuf:"varint,12,rep,packed,name=passive_spell,json=passiveSpell,proto3" json:"passive_spell,omitempty"`
	FlyUp                int32    `protobuf:"varint,13,opt,name=fly_up,json=flyUp,proto3" json:"fly_up,omitempty"`
	StarLevel            int32    `protobuf:"varint,14,opt,name=star_level,json=starLevel,proto3" json:"star_level,omitempty"`
	Quality              int32    `protobuf:"varint,15,opt,name=quality,proto3" json:"quality,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeroRecord) Reset()         { *m = HeroRecord{} }
func (m *HeroRecord) String() string { return proto.CompactTextString(m) }
func (*HeroRecord) ProtoMessage()    {}
func (*HeroRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_33865c398800497b, []int{21}
}

func (m *HeroRecord) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HeroRecord.Unmarshal(m, b)
}
func (m *HeroRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HeroRecord.Marshal(b, m, deterministic)
}
func (m *HeroRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeroRecord.Merge(m, src)
}
func (m *HeroRecord) XXX_Size() int {
	return xxx_messageInfo_HeroRecord.Size(m)
}
func (m *HeroRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_HeroRecord.DiscardUnknown(m)
}

var xxx_messageInfo_HeroRecord proto.InternalMessageInfo

func (m *HeroRecord) GetEntityId() uint32 {
	if m != nil {
		return m.EntityId
	}
